import path from 'path';
import {
  DIGITS,
  DIGITS_INCLUDING_RESET,
  DIGIT_KEY_MAP,
  MAX_COMMAND_LENGTH,
  MAX_LINE_LENGTH,
  MAX_PREVIEW_LENGTH,
} from './consts.js';
import { SayCommand } from './symbols.js';
import crypto from 'crypto';
``;
function SSBcmd(name) {
  return `SSB${name}`;
}
export function soundboardCompiler(sb, dirPrefix = '') {
  const waitLengthNewline = typeof sb.wait == 'number' ? sb.wait : 100;
  const helpDuration = typeof sb.help_duration == 'number' ? sb.help_duration : 4;
  const files = {
    cfg: `// Generated by source-soundboard
developer 1
con_filter_enable 2
con_notifytime ${helpDuration}
`,
    lines: {},
  };
  const helpTexts = {};

  // con_filter_enable doesn't update in the same tick, so we have to use a helper script to reset con_filter_text, which
  // does update as expected, but only when resetting it to empty.
  appendDigit('reset_con_filter', 'con_filter_text "";');
  alias(SSBcmd('cout'), exec('reset_con_filter'));
  // Only messages with this string will be shown in the developer top hand corner. It's gibberish
  // because we don't want anything to actually show there when not showing help text.
  // Generate gibberish based on the soundboard file, not randomness, so it is deterministic
  const gibberish = `%${crypto
    .createHash('sha256')
    .update(JSON.stringify(sb))
    .digest('base64')
    .substr(0, 9)}%`;
  alias(SSBcmd('reset'), bindDigits(DIGITS_INCLUDING_RESET).join(''));
  alias(SSBcmd('lock'), bindDigits(DIGITS_INCLUDING_RESET, true).join(''));
  alias(SSBcmd('endl'), `con_filter_text ${gibberish};`);
  alias(SSBcmd('locked'), echo(`Not currently locked`));

  traverse(sb);
  appendcfg(SSBcmd('reset'));
  appendcfg(SSBcmd('endl'));

  return files;

  function traverse(board, path = []) {
    const boardPath = path.join('');
    // Only digits assigned a `say`
    const pathDigits = [];
    // All digits, even `notfound` ones.
    const allDigits = [];

    if (board[0]) {
      throw new Error(
        `${[...path, '0'].join('.')}: Digit 0 is reserved for resetting the soundboard`
      );
    }

    for (const digit of DIGITS) {
      const currentPath = [...path, digit];
      const keyDigits = currentPath.join('.');
      const digits = currentPath.join('');
      allDigits.push(digits);

      if (!(digit in board)) {
        alias(SSBcmd(digits), `${SSBcmd('reset')};${echo(`[${digits}] unused`)}`);
        continue;
      }

      const value = board[digit];

      // Either raw strings or values from global helper functions (which add symbols to a `new String`)
      if (typeof value === 'string' || value instanceof String) {
        const saycode = say(value);
        const lineCount = saycode.length;
        const lineCountDigits = Math.log10(lineCount);
        const cmd = SSBcmd(digits);
        const execCommand = [(lineCount === 1 ? SSBcmd('reset') : SSBcmd('lock')) + ';'];

        // `wait` does not work in .cfgs, so we have to emit them in the alias. The following algorithm packs everything as tightly as possible
        // in accordance with the source max line limit.
        saycode.forEach((code, i) => {
          const sayFile =
            lineCount > 1
              ? `${digits}p${String(i + 1).padStart(lineCountDigits, '0')}`
              : digits;
          if (lineCount > 1) {
            if (i === lineCount - 1) {
              code += `\nalias ${SSBcmd('locked')} "${echo(
                'Not currently locked'
              )}";\n${echo(`[${digits}] finished`)}\n`;
            } else {
              code += `\nalias ${SSBcmd('locked')} "${echo(
                `[${digits}] playing ${i + 1} / ${lineCount}`
              )}";\n`;
            }
          }
          appendDigit(sayFile, code);
          execCommand.push(exec(sayFile));
        });

        const execChunks = [''];
        const maxCmdLength = MAX_COMMAND_LENGTH - 60; // Safe value to subtract for alias etc.
        execCommand.forEach((command, i) => {
          // [0] is the prefix command (reset/lock)
          const hasNext = i !== 0 && execCommand.length - 1 !== i;
          const fullCommand = hasNext ? `${command}wait ${waitLengthNewline};` : command;
          const nextChunk = `${cmd}c${String(execChunks.length + 1).padStart(
            lineCountDigits,
            '0'
          )}`;
          // Need to be able to emit the nextChunk code at all times. If not, we create a new chunk.
          const safeAppendLength =
            execChunks[execChunks.length - 1].length +
            fullCommand.length +
            nextChunk.length;
          if (safeAppendLength > maxCmdLength) {
            execChunks[execChunks.length - 1] += nextChunk;
            execChunks.push('');
          }
          execChunks[execChunks.length - 1] += fullCommand;
        });

        // Need to reset to remove the lock. This should be safe because of the liberal subtraction from MAX_COMMAND_LENGTH
        if (lineCount > 1) {
          execChunks[execChunks.length - 1] += SSBcmd('reset');
        }

        alias(cmd, execChunks[0]);
        if (execChunks.length > 1) {
          const chunkCountDigits = Math.log10(execChunks.length);
          execChunks.slice(1).forEach((chunk, i) => {
            alias(`${cmd}c${String(i + 2).padStart(chunkCountDigits, '0')}`, chunk);
          });
        }

        helpTexts[digits] = `[${digits}]${
          lineCount > 1 ? ` {${lineCount} lines}` : ''
        } ${value.replace(/\n/g, ' ')}`;
      } else if (value && typeof value === 'object') {
        const documentation =
          (typeof value._ === 'string' && value._) ||
          DIGITS.filter((d) => d in value).length + ' lines';
        helpTexts[digits] = `[${digits}] ${documentation}`;
        traverse(value, currentPath);
      } else {
        throw new Error(`soundboard.${keyDigits}: Not a string or object`);
      }
      pathDigits.push(digits);
    }

    pathDigits.sort();
    const boardDigits = boardPath || 0;
    appendDigit(
      boardDigits,
      // If there is no boardPath, allDigits will be the same as DIGITS. reset() is the same as bindDigits(DIGITS)
      `${boardPath ? bindDigits(allDigits).join('\n') : SSBcmd('reset')}\n${SSBcmd(
        'cout'
      )};\n${echoHelpTexts(pathDigits.map((d) => helpTexts[d]))}\n${SSBcmd('endl')}`
    );

    alias(SSBcmd(boardDigits), exec(boardDigits));
    return pathDigits;
  }

  function appendcfg(data) {
    files.cfg += `${data}\n`;
  }

  function appendDigit(digit, data) {
    const filename = `${digit}.cfg`;
    if (!files.lines[filename]) {
      files.lines[filename] = ``;
    }
    files.lines[filename] += `${data}\n`;
  }

  function echo(text) {
    return `${SSBcmd('cout')};echo ${text};${SSBcmd('endl')}`;
  }

  function exec(digit) {
    return `exec ${path.join(dirPrefix, `${digit}.cfg`)};`;
  }

  /**
   * @param {string[]} texts
   */
  function echoHelpTexts(texts) {
    texts = texts.map((text) => {
      const sanitized = sanitizeLine(text);
      return sanitized.length > MAX_PREVIEW_LENGTH
        ? `${sanitized.substr(0, MAX_PREVIEW_LENGTH - 3)}...`
        : sanitized;
    });

    // developer_1 will only show 6 lines at a time, so if there are more than that we will need to condense help text into fewer lines.
    let lines = texts.slice(0, 6);
    if (texts.length > 6) {
      // Pad the text to the longest line shown to make it easier to understand
      const longestLineLength = lines.reduce(
        (longest, line) => (line.length > longest ? line.length : longest),
        0
      );
      texts.slice(6).forEach((text, i) => {
        lines[i] = `${lines[i].padEnd(longestLineLength, ' ')} ${text}`;
      });
    }

    return lines.map((line) => `echo "${line}";`).join('\n');
  }

  function alias(token, command) {
    const line = `alias ${token} ${wrapCommand(command)}`;
    if (line.length > MAX_COMMAND_LENGTH) {
      throw new Error(`Line ${line} exceeds Source's max command length`);
    }
    appendcfg(line);
  }

  /**
   * @param {string} command Must be a single command (use an alias if you need multiple commands)
   */
  function bind(key, command) {
    const line = `bind ${DIGIT_KEY_MAP[key]} ${command};`;
    if (line.length > MAX_COMMAND_LENGTH) {
      throw new Error(`Line ${line} exceeds Source's max command length`);
    }
    return line;
  }

  function bindDigits(pathDigits, lock = false) {
    return pathDigits.map((pathDigit) => {
      const digits = String(pathDigit);
      return bind(
        digits.substr(digits.length - 1),
        lock ? SSBcmd(`locked`) : SSBcmd(digits)
      );
    });
  }
}

// line can be a string or new String
function say(line) {
  const text = sanitizeLine(line);
  const message = [];
  const words = text.split(' ');
  let i = 0;
  const sayCommand = line[SayCommand] || 'say';

  while (i < words.length) {
    let lineWords = '';

    for (; i < words.length; i += 1) {
      let word = words[i];
      // If the line is a single word (no spaces), try to cut into that word
      if (lineWords.length === 0 && word.length > MAX_LINE_LENGTH) {
        word = words[i] = words[i].substr(0, MAX_LINE_LENGTH);
        lineWords = word;
        break;
      }

      // Re-add space (removed by split)
      if (lineWords.length) lineWords += ' ';
      // emit say
      if (lineWords.length + word.length > MAX_LINE_LENGTH) {
        break;
      }
      // If the word contains a newline, create a hard break
      if (word.includes('\n')) {
        lineWords += word.substr(0, word.indexOf('\n'));
        word = words[i] = words[i].substr(word.indexOf('\n') + 1);
        break;
      }

      lineWords += word;

      if (i + 1 < words.length) {
        const lastWord = word[word.length - 1];
        // Always send a new message when a newline is found
        if (lastWord === '\n') {
          break;
        }
      }
    }

    lineWords = lineWords.trim();
    if (lineWords.length === 0) {
      break;
    }

    message.push(`${sayCommand} "${lineWords}";`);
  }

  return message;
}

// Helpers that don't depend on the state

function sanitizeLine(line) {
  return (
    line
      .replace(/  /g, ' ')
      .trim()
      // There is no way to escape these characters in a .cfg
      .replace(/"/g, 'â€œ')
    // '//' creates a comment, even inside a string
    // .replace(/\/\//g, '/ /')
  );
}

function wrapCommand(command) {
  if (!command) return '""';
  // Remove trailing ;
  if (command[command.length - 1] === ';') {
    command = command.substr(0, command.length - 1);
  }
  return '"' + command + '"';
}
