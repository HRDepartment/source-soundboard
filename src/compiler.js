import path from 'path';
import {
  DIGITS,
  DIGIT_KEY_MAP,
  MAX_COMMAND_LENGTH,
  MAX_LINE_LENGTH,
  MAX_PREVIEW_LENGTH,
} from './consts.js';
import { SayCommand } from './symbols.js';
import crypto from 'crypto';

function SSBcmd(name) {
  return `SSB${name}`;
}
export function soundboardCompiler(sb, dirPrefix = '') {
  const waitLengthNewline = typeof sb.wait == 'number' ? sb.wait : 100;
  const helpDuration = typeof sb.help_duration == 'number' ? sb.help_duration : 4;
  const files = {
    cfg: `// Generated by source-soundboard
developer 1
con_filter_enable 2
con_notifytime ${helpDuration}
`,
    lines: {},
  };
  const helpTexts = {};

  // con_filter_enable doesn't update in the same tick, so we have to use a helper script to reset con_filter_text, which
  // does update as expected, but only when resetting it to empty.
  appendDigit('reset_con_filter', 'con_filter_text "";');
  alias(SSBcmd('cout'), exec('reset_con_filter'));
  // Only messages with this string will be shown in the developer top hand corner. It's gibberish
  // because we don't want anything to actually show there when not showing help text.
  // Generate gibberish based on the soundboard file, not randomness, so it is deterministic
  const gibberish = `%${crypto
    .createHash('sha256')
    .update(JSON.stringify(sb))
    .digest('base64')
    .substr(0, 9)}%`;
  alias(SSBcmd('endl'), `con_filter_text ${gibberish};`);

  traverse(sb);
  alias(`SSBreset`, bindDigits(DIGITS).join(''));
  // Resets current input and displays root options
  appendcfg(bind(0, SSBcmd('0')));
  appendcfg(SSBcmd('reset'));
  appendcfg(SSBcmd('endl'));

  return files;

  function traverse(board, path = []) {
    const boardPath = path.join('');
    // Only digits assigned a `say`
    const pathDigits = [];
    // All digits, even `notfound` ones.
    const allDigits = [];

    if (board[0]) {
      throw new Error(
        `${[...path, '0'].join('.')}: Digit 0 is reserved for resetting the soundboard`
      );
    }

    for (const digit of DIGITS) {
      const currentPath = [...path, digit];
      const keyDigits = currentPath.join('.');
      const digits = currentPath.join('');
      allDigits.push(digits);

      if (!(digit in board)) {
        alias(
          SSBcmd(digits),
          `${SSBcmd('reset')};${SSBcmd('cout')};echo [${digits}] unused;${SSBcmd('endl')}`
        );
        continue;
      }

      const value = board[digit];

      // Either raw strings or values from global helper functions (which add symbols to a `new String`)
      if (typeof value === 'string' || value instanceof String) {
        const saycode = say(value, waitLengthNewline);
        const lineCount = saycode.reduce(
          (count, line) => (line.startsWith('wait ') ? count + 1 : count),
          1
        );
        const cmd = SSBcmd(digits);
        appendDigit(digits, saycode.join('\n'));
        alias(`${cmd}`, exec(digits) + SSBcmd('reset'));
        // alias(`-${cmd}`, reset());
        helpTexts[digits] = `[${digits}]${
          lineCount > 1 ? ` {${lineCount} lines}` : ''
        } ${value.replace(/\n/g, ' ')}`;
      } else if (value && typeof value === 'object') {
        const documentation =
          (typeof value._ === 'string' && value._) ||
          DIGITS.filter((d) => d in value).length + ' lines';
        helpTexts[digits] = `[${digits}] ${documentation}`;
        traverse(value, currentPath);
      } else {
        throw new Error(`soundboard.${keyDigits}: Not a string or object`);
      }
      pathDigits.push(digits);
    }

    pathDigits.sort();
    const boardDigits = boardPath || 0;
    appendDigit(
      boardDigits,
      // If there is no boardPath, allDigits will be the same as DIGITS. reset() is the same as bindDigits(DIGITS)
      `${boardPath ? bindDigits(allDigits).join('\n') : SSBcmd('reset')}\n${SSBcmd(
        'cout'
      )};\n${echoHelpTexts(pathDigits.map((d) => helpTexts[d]))}\n${SSBcmd('endl')}`
    );

    alias(SSBcmd(boardDigits), exec(boardDigits));
    return pathDigits;
  }

  function appendcfg(data) {
    files.cfg += `${data}\n`;
  }

  function appendDigit(digit, data) {
    const filename = `${digit}.cfg`;
    if (!files.lines[filename]) {
      files.lines[filename] = `// Generated by source-soundboard\n`;
    }
    files.lines[filename] += `${data}\n`;
  }

  function exec(digit) {
    return `exec ${path.join(dirPrefix, `${digit}.cfg`)};`;
  }

  /**
   * @param {string[]} texts
   */
  function echoHelpTexts(texts) {
    texts = texts.map((text) => {
      const sanitized = sanitizeLine(text);
      return sanitized.length > MAX_PREVIEW_LENGTH
        ? `${sanitized.substr(0, MAX_PREVIEW_LENGTH - 3)}...`
        : sanitized;
    });

    // developer_1 will only show 6 lines at a time, so if there are more than that we will need to condense help text into fewer lines.
    let lines = texts.slice(0, 6);
    if (texts.length > 6) {
      // Pad the text to the longest line shown to make it easier to understand
      const longestLineLength = lines.reduce(
        (longest, line) => (line.length > longest ? line.length : longest),
        0
      );
      texts.slice(6).forEach((text, i) => {
        lines[i] = `${lines[i].padEnd(longestLineLength, ' ')} ${text}`;
      });
    }

    return lines.map((line) => `echo "${line}";`).join('\n');
  }

  function alias(token, command) {
    if (command.length > MAX_COMMAND_LENGTH) {
      throw new Error(`Line ${command} exceeds Source's max command length`);
    }
    appendcfg(`alias ${token} ${wrapCommand(command)}`);
  }

  /**
   * @param {string} command Must be a single command (use an alias if you need multiple commands)
   */
  function bind(key, command) {
    if (command.length > MAX_COMMAND_LENGTH) {
      throw new Error(`Line ${command} exceeds Source's max command length`);
    }
    return `bind ${DIGIT_KEY_MAP[key]} ${command};`;
  }

  function bindDigits(pathDigits) {
    return pathDigits.map((pathDigit) => {
      const digits = String(pathDigit);
      return bind(digits.substr(digits.length - 1), `${SSBcmd(digits)}`);
    });
  }
}

// line can be a string or new String
function say(line, waitLengthNewline) {
  const text = sanitizeLine(line);
  const message = [];
  const words = text.split(' ');
  let i = 0;
  const sayCommand = line[SayCommand] || 'say';

  while (i < words.length) {
    let lineWords = '';

    for (; i < words.length; i += 1) {
      let word = words[i];
      // If the line is a single word (no spaces), try to cut into that word
      if (lineWords.length === 0 && word.length > MAX_LINE_LENGTH) {
        word = words[i] = words[i].substr(0, MAX_LINE_LENGTH);
        lineWords = word;
        break;
      }

      // Re-add space (removed by split)
      if (lineWords.length) lineWords += ' ';
      // emit say
      if (lineWords.length + word.length > MAX_LINE_LENGTH) {
        break;
      }
      // If the word contains a newline, create a hard break
      if (word.includes('\n')) {
        lineWords += word.substr(0, word.indexOf('\n'));
        word = words[i] = words[i].substr(word.indexOf('\n') + 1);
        break;
      }

      lineWords += word;

      if (i + 1 < words.length) {
        const lastWord = word[word.length - 1];
        // Always send a new message when a newline is found
        if (lastWord === '\n') {
          break;
        }
      }
    }

    lineWords = lineWords.trim();
    if (lineWords.length === 0) {
      break;
    }

    message.push(`${sayCommand} "${lineWords}";`);
    // wait if there is another line coming
    if (words.length - i > 1) {
      message.push(`wait ${waitLengthNewline};`);
    }
  }

  return message;
}

// Helpers that don't depend on the state

function sanitizeLine(line) {
  return (
    line
      .replace(/  /g, ' ')
      .trim()
      // There is no way to escape these characters in a .cfg
      .replace(/"/g, 'â€œ')
    // '//' creates a comment, even inside a string
    // .replace(/\/\//g, '/ /')
  );
}

function wrapCommand(command) {
  if (!command) return '""';
  // Remove trailing ;
  if (command[command.length - 1] === ';') {
    command = command.substr(0, command.length - 1);
  }
  return '"' + command + '"';
}
